#include "ti_msp_dl_config.h"

//使用0,1方式实现延时需要关闭systick中断 To achieve delay using the 0,1 method, the systick interrupt needs to be turned off
//以下通过三种方式实现延时 0:通过无操作循环来实现延时 1:通过轮询读取systick计数来实现延时  2:通过systick中断来实现延时(默认使用)如果使用前两种需要关闭systick中断 
//Delay can be achieved through systick interrupts (default usage). If the first two are used, systick interrupts need to be turned off

#define DELAY_SELECT 1
volatile unsigned int delay_times = 0;


//自定义延时（不精确） Custom delay (not precise)
#if DELAY_SELECT==0
void delay_ms(unsigned int ms)
{
    unsigned int i, j;
    // 下面的嵌套循环的次数是根据主控频率和编译器生成的指令周期大致计算出来的，
    // 需要通过实际测试调整来达到所需的延时。
    // The number of nested loops below is roughly calculated based on the master control frequency and the instruction cycle generated by the compiler,and needs to be adjusted through actual testing to achieve the required delay.
    for (i = 0; i < ms; i++)
    {
        for (j = 0; j < 8000; j++) 
        {
            // 仅执行一个足够简单以致于可以预测其执行时间的操作
            // Perform only one operation that is simple enough to predict its execution time
            __asm__("nop"); // "nop" 代表“无操作”，在大多数架构中，这会消耗一个或几个时钟周期不固定 "nop" stands for "no operation", which on most architectures consumes one or a few clock cycles unset
        }
    }
}

#elif  DELAY_SELECT==1
//通过systick轮询读取来实现延时 Latency is achieved through systick polling read
void delay_us(unsigned long __us) 
{
    uint32_t ticks;
    uint32_t told, tnow, tcnt = 0;

    ticks = __us * (80000000 / 1000000);  // 80MHz 时钟
    told = SysTick->VAL;

    while (1)
    {
        tnow = SysTick->VAL;
        if (tnow != told)
        {
            if (tnow < told)
                tcnt += told - tnow;
            else
                tcnt += (SysTick->LOAD + 1) - tnow + told;

            told = tnow;
            if (tcnt >= ticks)
                break;
        }
    }
}

//搭配滴答定时器实现的精确ms延时 Precise ms delay achieved in conjunction with a tick timer
void delay_ms(unsigned long ms) 
{
    while (ms--)
    {
        delay_us(1000);  // 每次延时 1ms
    }
}
				
#else

//通过systick中断实现延时 需要在sysconfig中打开systick中断  To achieve delay through systick interrupt, you need to enable systick interrupt in sysconfig
void delay_ms(unsigned int ms)
{
	delay_times=ms;
	while(delay_times!=0);
}


void SysTick_Handler(void)
{
		if( delay_times != 0 )
		{
				delay_times--;
		}
		

}
#endif




 // 微秒级延时 Microsecond delay 

void delay_1us(unsigned long __us) 
{ 
    delay_us(__us);  
}

//毫秒级延时函数 Millisecond-level delay 


void delay_1ms(unsigned long ms) 
{ 
    delay_ms(ms);  
}